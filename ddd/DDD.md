# 도메인 주도 설계

## 도메인 주도 설계 등장 배경

- 데이터 종속적인 애플리케이션 (데이터베이스 위주의 개발)
- 데이터 베이스 스키마가 정해지면 모든 코드가 정해진다 (모델링과 개발과의 불일치)
- 잘못된 소프트웨어를 만드는 원인이 되기도 한다

## 도메인 주도 설계란

- 도메인 모델의 적용 범위를 구현까지 확장하여 도메인 지식을 구현 코드에 반영
- 기존 설계방식의 불일치를 해소하기 위한 노력 중 하나
- 공통의 언어를 사용하여 도메인과 구현을 충분히 만족하는 모델을 만드는 것
- 실제 코드로 구현 가능한 현실성 있는 도메인 모델 분석과 그것을 추상화하는 설계 방법
- 설계를 먼저 하고 구축 하라는 것이 아니다 !

## 도메인

- 일반적인 요구사항, 전문 용어, 그리고 컴퓨터 프로그래밍 분야에서 문제를 풀기 위해 설계된 어떤 소프트웨어 프로그램에 대한 기능성을 정의하는 연구의 한 영역
- 소프트웨어로 해결하고자 하는 문제 영역

## 도메인 모델

- 특정 도메인을 개념적으로 표현한 것
- Points of interest
- 선택된 일부를 나타내는 추상화 시스템
- 도메인 모델을 사용하면 여러 관계자들이 동일한 모습으로 도메인을 이해하고 도메인 지식을 공유하는 데 도움이 된다.

## 도메인 주도 설계의 3가지 기둥

- 전략적 설계  - 바운디드 컨텍스트, 컨텍스트 맵
- 전술적 설계 - 엔티티, 레포지터리, 에그리게이트
전술적 설계는 전략적 설계의 구현체이며 전술적설계만 반영하는 것을 빌딩 블록이나 DDD lite, 도메인 모델 패턴이라 부르기도 한다.
- 유비쿼터스언어(공통된 언어) 사용
    - 도메인에서 사용하는 용어를 코드에 반영하지 않으면 그 코드는 개발자에게 코드의 의미를 해석해야 하는 부담을 준다.
    - 코드의 가독성을 높여서 코드를 분석하고 이해하는 시간을 절약한다.
    - 용어가 정의 될 때마다 용어 사전에 이를 기록하고 명확하게 정의 함으로써 추후 또는 다른 사람들도 공통된 언어를 사용할 수 있도록 한다.

## BOUNDED CONTEXT

- 하위 도메인마다 같은 용어라도 의미가 다르고 같은 대상이라도 지칭하는 용어가 다를 수 있기 때문에 한 개의 모델로 모든 하위 도메인을 표현하려는 시도는 올바른 방법이 아니며 표현할 수도 없다
- 하위 도메인마다 사용하는 용어가 다르기 때문에 올바른 도메인 모델을 개발하려면 하위 도메인마다 모델을 만들어야 한다
- 모델은 특정한 컨텍스트(문맥)하에서 완전한 의미를 갖는다
- 이렇게 구분되는 경계를 갖는 컨텍스트를 DDD에서는 BOUNDED CONTEXT라고 한다
- 좋은 BOUNDED CONTEXT는 하나의 팀에만 할당되어야 한다

## 컨텍스트 맵

- 컨텍스트 맵은 상호 교류하는 시스템의 목록을 제공하고, 팀 내 의사소통의 촉매 역할을 한다
- 예를 들어 컨텍스트 끼리 통신을 주고 받는다고 하였을때, 이런 데이터의 흐름이 어떻게 흐르는 지 요청을 하는지, 요청을 받는 방식 등을 표현하는 것을 컨테스트 맵이라 한다.

## 엔티티와 밸류

- 엔티티는 데이터만 가지고 있는 것이 아닌 도메인 기능을 제공한다 (객체지향적으로 설계하자)
- 밸류 타입은 불변 이다
- 엔티티는 고유한 식별자를 갖는다

## Aggregate

- 관련 객체를 하나로 묶은 군집
- 애그리거트는 군집에 속한 객체들을 관리하는 루트 엔티티를 갖는다 = 애그리거트 루트
    - 애그리거트 루트의 핵심 역할은 애그리거트의 일관성이 깨지지 않도록 하는것이다
    - 애그리거트 루트는 애그리거트가 제공해야할 도메인 기능을 제공하고 내부 구현을 캡슐화한다
- 애그리거트로 묶어서 바라보면 좀 더 상위 수준에서 도메인 모델 간의 관계를 파악할 수 있다
- 애그리거트에 속한 객체는 유사하거나 동일한 라이프 사이클을 갖는다
- 한 애그리거트에 속한 객체는 다른 애그리거트에 속하지 않는다
- 두 개 이상의 엔티티로 구성되는 애그리거트는 드물게 존재한다

## 도메인 서비스

- 한 애그리거트에 넣기 애매한 도메인 개념을 구현하려면 애그리거트에 억지로 넣기보다는 도메인 서비스를 이용해서 도메인 개념을 명시적으로 드러내면 된다.
- 응용 영역의 서비스가 용용 로직을 다룬다면 도메인 서비스는 도메인 로직을 다룬다.
- 도메인 영역의 애그리거트나 밸류와 같은 다른 구성요소와 비교할 때 다른 점은 상태 없이 로직만 구현한다.
- 서비스를 사용하는 주체는 애그리거트가 될 수도 있고 응용 서비스가 될 수도 있다.
- 애그리거트 메서드를 실행할 때 도메인 서비스를 인자로 전달하지 않고 반대로 도메인 서비스의 기능을 실행할 때 애그리거트를 전달하기도 한다.
- 특정 기능이 응용 서비스인지 도메인 서비스인지 감을 잡기 어려울 때는 해당 로직이 애그리거트의 상태를 변경하거나 애그리거트의 상태 값을 계산하는지 검사해 보면 된다.
- 즉, **도메인 서비스는 도메인 계층의 비즈니스 로직이 응용 계층으로 나가는걸 막아주는 방파제**이다.

## 의존 역전 원칙(DIP)

- 저수준 모듈이 고수준 모듈에 의존한다고 해서 이를 DIP(Dependency Inversion Principle, 의존 역전 원칙)라고 부른다.
    - 고수준 모듈 : 어떤 의미 있는 단일 기능을 제공하는 모듈 (e.g. 가격 할인 계산)
    - 저수준 모듈 : 고수준 모듈의 기능을 구현하기 위해 필요한 하위 기능의 실제 구현
    (e.g. ~를 통한 가격할인 계산)
- 인프라스트럭처 영역에 의존할 때 발생했던 구현 교체가 어렵다는 문제와 테스트가 어려운 문제를 해소할 수 있다.
- 고수준 모듈은 더 이상 저수준 모듈에 의존하지 않고 구현을 추상화한 인터페이스에 의존한다.

## 클린 아키텍처

- 클린 아키텍처의 핵심은 도메인 모델을 외부로 노출하지 않고 보호한다는 것이다.

## 참고

- 우아한테크캠프 pro - NEXTSTEP
