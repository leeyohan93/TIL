# 취업

## 3.1 5개 이하의 public 메서드만 노출하세요

- 가장 우아하고, 유지보수 가능하고, 응집력이 높으면서, 테스트하기도 용이한 객체는 **작은** 객체입니다.
- 클래스가 작으면 메서드와 프로퍼티가 더 **가까이** 있을 수 있기 때문에 응집도가 높아집니다.
- 메서드를 5개 이하로 유지하세요. 이게 전부입니다.

## 3.2 정적 메서드를 사용하지 마세요

정적 메서드는 소프트웨어를 유지보수하기 어렵게 만듭니다.

### 3.2.1 객체 대 컴퓨터 사고

- 정적 메서드는 OOP와 아무런 관련이 없으며, 객체지향 언어의 문법을 이용해서 절차적인 코드를 작성하도록 부추길 뿐입니다.

    ```java
    int x = Math.max(5, 9); // 잘못된 방식
    
    Number x = new Max(5, 9); // 올바른 방식
    ```

- 위 코드에서 올바른 방식은 최댓값을 계산하지 않고 그저 x가 5와 9의 최댓값`**이라는(is-a)`** 사실을 정의할 뿐입니다. 이러한 특징은 함수형, 논리형, 객체지향 프로그래밍이 절차적 프로그래밍과 차별화되는 점입니다.

### 3.2.2 선언형 방식 대 명령형 방식

- 위에서 두 방식을 명령형 방식과 선언형 방식이라고 이야기할 수 있는데, 이 때 선언형 방식이 더 좋습니다. 이제부터 그 이유에 대해서 이야기하겠습니다.

    ```java
  int y = Math.between(5, 9, 13); // 명령형 방식
  
  int y = new Between(5, 9, 13); // 선언형 방식
    ```


1. 첫번째 이유는 선언형 방식이 **더 빠릅니다**.
   위 예제에서는 Between 클래스의 인스턴스를 생성하는데 걸리는 시간이 정적 메서드인 between()을 호출하는데 걸리는 시간보다 더 오래걸립니다. 하지만 오직 정적 메서드 하나만 호출하는 경우가 아니라, 다수의 정적 메서드를 호출해야하는 경우에는 이야기가 다릅니다. 이 때는 선언형 방식을 최적화할 수 있기 때문에 더 빠르게 동작합니다. 이에 대한 간단한 예제는 아래와 같습니다.

    ```java
    // 명령형 방식
    public void doInt() {
        int x = Math.between(5, 9, 13);
   
        if(/* x가 필요한가? */) {
            System.out.println("x=" x);
        }
    }
    
    // 선언형 방식
    public void doInt() {
        Integer x = new Between(5, 9, 13);
        if(/* x가 필요한가? */) {
           System.out.println("x=" x);
        }
    }
    ```

- 선언형 방식은 CPU에게 모든 것을 계산하라고 말하지 않았습니다. 대신 CPU에게 결과가 실제로 필요한 시점과 위치를 결정하도록 위임하고, CPU는 요청이 있을 경우에만 계산을 합니다. (Between 내부적으로는 아직 계산하기 이전의 상태입니다)
2. 선언형 방식이 더 좋은 두번째 이유는 **다형성** 때문입니다.
   다형성이란 코드 블록 사이의 의존성을 끊을 수 있는 능력을 말합니다. 이 때, 객체를 다른 객체로부터 완전히 분리하기 위해서는 메서드나 주생성자 어디에서도 new 연산자를 사용하지 말아야합니다.

    ```java
    class Between implements Number {
        private final Number num;
        
        // 의존성이 높은 생성자 -> 객체를 분리하기 힘들다.	
        Between(int left, int right, int x) {
           this(new Min(new Max(left, x), right);
        }
    
        // 의존성이 낮은 생성자 -> 객체를 분리하기 쉽다.
        Between(Number number) {
           this.num = number;
        }
    }
    ```


3. 선언형 방식이 더 좋은 세 번째 이유는 **표현력** 때문입니다.

    ```java
    // 명령형 방식
    Collection<Integer> evens = new ArrayList<>();
    for (int number : numbers) {
        if (number % 2 == 0) {
            evens.add(number);
        }
    }
    ```

- 이 코드가 하는 일을 이해하기 위해서는 코드의 실행결로를 추적하고, 코드 안의 루프를 `마음 속으로 시각화`해야 합니다. 아래는 동이한 로직을 선언형 스타일로 작성한 예입니다.

    ```java
    // 선언형 방식
    Collection<Integer> evens = new Filtered(
        numbers,
        new Predicate<Integer>() {
            @Override
            public boolean suitable(Integer number) {
                return number % 2 == 0;
            }
        }
    }
    ```

- 이 코드는 명령형 방식의 코드보다 영어에 훨신 가깝고 글자 그대로 "evens는 짝수만 포함하는 필터링된 컬렉션입니다"라고 읽힙니다. 코드에는 구현과 관련된 세부 사항은 감춰져 있고, 오직 행동만 표현되어 있습니다.
- 첫번째 코드가 읽기 더 편하게 느껴지는 사람들도 있을 것입니다. 첫 번째 코드가 더 짧아서 일수도, 자주 접해오던 코드와 비슷하기 때문일 수 있습니다. 하지만 **알고리즘**과 **실행** 대신 **객체**와 **행동**의 관점에서 사고하기 시작하면 무엇이 올바른지 느껴지게 될 것입니다.

4. 네 번째 이유는 코드 **응집도** 때문입니다.
- 앞의 두 예제를 보면 명령형 방식의 경우 (코드가 순차적으로 실행되어야하는) **시간적인 결합**이 되어있습니다. 선언형 방식을 사용하면 시간적인 결합을 제거하고 유지보수성을 개선할 수 있습니다.

- 하지만 이미 모든 코드가 정적 메서드로 가득차 있다면 어떻게 해야할까요? 이런 경우 정적 메서드를 감싸는 클래스를 만들어 정적 메서드가 오염시키는 부분을 고립시키는 것입니다.

```java
class FileLines implements Iterable<String> {
    private final File file;
    
    public Iterator<String> iterator() {
       return Arrays.asList<FileUtils.readLines(this.file)).iterator();
    }
}
```

- 정적 메서드는 오직 FileLines 안에서만 호출되기 때문에 언젠가는 모든 정적 메서드호출을 제거할 수 있을 것입니다.

### 3.2.3 유틸리티 클래스

- 유틸리티 클래스는 절차적인 프로그래머들이 OOP라는 영토에서 거둔 승리의 상징입니다. 유틸리티 클래스는 정적 메서드처럼 단순히 나쁜 요소가 아닙니다. 나쁜 요소들을 모아 놓은 집합체입니다. 유틸리티 클래스는 정적 메서드를 설명하면서 나열했던 모든 단점들을 몇 배로 증폭시킵니다. 유틸리티 클래스는 끔찌갛ㄴ 아티 패턴입니다. 가까이하지 마세요.

### 3.2.4 싱글톤 패턴

- 싱글톤은 유명한 디자인 패턴이지만, 사실 끔찍한 **안티 패턴**입니다.
- 유틸리티 클래스와 싱글톤 클래스를 구분하는 핵심전인 차이는 싱글톤은 분리가 가능한 의존서응로 연결되어 있는데 반해, 유틸리티 클래스는 분리가 불가능한 하드코딩된 결합도를 가진다는 것입니다. 다시 말해서 싱글톤의 장점은 getInstance()와 함께 setInstance()를 추가할 수 있다는 점입니다.
- 만약 소프트웨어의 전체 클래스들이 사용해야 하는 기능을 구현해야할 때, 예를 들어 로그인 사용자 정보를 알아야 한다고 가정해보겠습니다. 이 때, 싱글톤에 대한 대안은 필요한 모든 객체안에서 사용자를 캡슐화 하는 것입니다.

### 3.2.5 함수형 프로그래밍

FP에서는 오직 함수만 사용할 수 있지만 OOP에서는 객체와 메서드를 조합할 수 있습니다. FP는 훌륭한 패러다임이지만, OOP가 더 낫습니다. 특히 제대로 사용할 경우에는 더 확실해집니다.

### 3.2.6 조합 가능한 데코레이터

```java
names = new Sorted(
    new Unique(
       new Capitalized(
           new Replaced(
               new FileNames(
                   new Directory(
                       "/var/user/*.xml"
                   )
               ),
               "([^.]+\\.xml",
               "$1"
           )
       )
    )
);
```

- 이 코드가 깔금하고 이해하기 쉽다는 사실이 이해되나요? 지금까지 설명햇떤 내용들을 떠올리면서 그런 느낌을 받기를 기대합니다.

### 결론

- 객체지향 프로그래밍이란 더 작은 객체들을 기반으로 더 큰 객체들을 조합하는 작업입니다.
- 정적 메서드를 포함하는 작은 객체들을 조합해서 더 큰 객체를 만들 수 없습니다. 간단히 말해서 정적 메서드는 **합성(composition)**이라는 아이디어와 대치됩니다.
- 결론적으로는 소프트웨어 어디에서도 static 키워드를 사용해서는 안됩니다.

## 3.3 인자의 값으로 NULL을 절대 허용하지 마세요

- 코드 어딘가에서 null이 존재한다면 여러분은 커다란 실수를 저지르고 있는 것입니다.
- 객체를 존중했다면 존재 여부를 객체 스스로 결정하게 해야합니다.
- OOP에서 `존재하지 않는 인자(absend agrgument)`문제는 `널 객체(null object)`를 이용해서 해결해야합니다. 전달할 것이 없다면 비어있는 것처럼 행동하는 객체를 전달하거나, 전달한 객체에게 무리한 요청을 한다면 응답을 거부하도록 구현해야합니다.
- 메서드가 인자의 값으로 Null을 허용하지 않기로 했다고 가정했을 때 **,**널을 처리하는 방법 두가지
    - 방어적인 방법으로 null 체크를 한후에 예외를 발생
    - null을 무시하는 방법, null에 대한 가정과 대비를 하지 않아 NPE가 발생한다면 메서드 호출자가 실수했다는 사실을 인지하게 하는것. (개인적으로 선호)

## 3.4 충성스러우면서 불변이거나, 아니면 상수이거나

## 3.5 절대 getter와 setter를 사용하지 마세요

- getter와 setter는 OOP가 지향하는 가장 중요한 설계 원칙 중 하나인 캡슐화를 위반하는 안티 패턴입니다.
- 객체지향적이고 선언형 스타일을 유지하기 위해서는, 데이터를 객체 안에 감추고 절대로 외부에 노출해서는 안됩니다. 정확하게 무엇을 캡슐화하고 있고, 자료구조가 얼마나 복잡한 지는 오직 객체만이 알고 있어야 합니다.

## 3.6 부생성자 밖에서는 new를 사용하지 마세요

- 부생성자 이외에서 new를 사용하게 될 경우 `하드코딩된 의존성` 이 생기게 됩니다.

```java
class Cash {
    private final int dollars;

    public int euro() {
        return new Exchange().rate("USD", "EUR") * this.dollars;
    }
}
```

- 만약 현재와 같은 설계에서 Exchange가 외부 서버와 통신한다면, 해당 메서드를 테스트할 때마다 외부서버에 접근하게 될 것입니다. 이러한 상황은 소프트웨어를 테스트하고 유지보수하기 어렵게 만듭니다.

```java
class Cash {
    private final int dollars;
    private final Exchange exchange;

    // 부생성자
    Cash(int value) {
        this(value, new NYSE());
    }

    Cash(int value, Exchange exch) {
        this.dollars = value;
        this.exchange = exch;
    }

    public int euro() {
        return exchange.rate("USD", "EUR") * this.dollars;
    }
}
```

- 다음 코드와 같이 의존성 주입을 하게 되면 테스트와 유지보수에 좋은 코드가 완성되는데, 그 이유는 의존성을 제어하는 주체가 Cash가 아니라 우리 자신이기 때문입니다.

### 결론

- new를 사용해도 좋은 곳은 부생성자 이외에는 없습니다.
    - 메서드에서 new를 사용하여 반환한다면, 해당 기능을 수행하는 인스턴스를 내부적으로 선언하고 의존성 주입하는 방향으로 가져가야합니다.

## 3.7 인트로스펙션과 캐스팅을 피하세요

- 타입 인트로스펙션과 캐스팅을 사용하고 싶은 유혹에 빠지더라도 절대로 사용해서는 안됩니다.
- 기술적으로 Java의 instanceof 연산자와 Class.cast() 메서드 등 동일한 기능을 수행하는 연산자들이 모두 이 범주에 포함됩니다.

```java
public <T> int size(Iterable<T> items) {
    if (items instanceof Collection) {
       return Collection.class.cast(items).size();
    }
    
    int size = 0;
    for (T item: items) {
       ++size;
    }
    return size;
}
```

- 다음과 같이 객체를 차별하는 것은 OOP의 기본 사상을 심각하게 훼손하게되며, 런타임에 객체의 타입을 조사하는 것은 클래스 사이의 결합도가 높아지기 때문에 기술적인 관점에서도 좋지 않습니다.
- 이런 문제들은 오버로딩이나 다형성을 통해 적절하게 풀어야합니다.