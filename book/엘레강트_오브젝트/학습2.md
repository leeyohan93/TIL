# 학습 2/n

## 2.5 퍼블릭 상수(Public Constant)를 사용하지 마세요

'상수(constant)'라고도 불리는 public static final 프로퍼티는 객체 사이에 데이터를 공유하기 위해 사용하는 매우 유명한 매커니즘입니다.

하지만 객체들은 어떤 것도 공유해서는 안됩니다. 대신 독립적이고 '닫혀 있어야 (closed)' 합니다.
간단하게 말해서 상수를 이용한 공유 메커니즘은 캡슐화와 객체지향적인 사고 전체를 부정하는 일입니다.

아래와 같은 Constants 클래스를 추가하고 여러 객체에서 Cnstatns.EOL을 사용하는 코드는 불행하게도 코드의 중복이라는 하나의 문제를 해결하기 위해 두 개의 더 큰 문제를 추가하고 있습니다.
첫번째는 결합도(coupling)이 높아진 것이며 두번째는 응집도(cohesion)가 낮아진 것입니다.

```java
public class Constants {
    public static final String EOL = "\r\n";
```

### 결합도 증가

Constants를 상수로 사용하는 클래스들은 모두 같은 객체를 의존하고 있으며, 이 의존성은 하드코딩 되어있습니다. 이 경우는 의존성을 쉽게 분리할 수 있는 방법이 없습니다. 그렇다면 만약 Constant.EOL 내용을 수정하게 된다면 이 상수를 사용하는 클래스들은 예상할 수 없는 방향으로 변경될 것입니다.
즉, 많은 객체들이 다른 객체를 사용하는 상황에서 서로를 어떻게 사용하는지 알 수 없다면, 이 객체들은 매우 강하게 결합되어 있는것입니다.

### 응집도 저하

퍼블릭 상수를 사용하면 객체의 응집도는 낮아지고 낮은 응집도는 객체가 자신의 문제를 해결하는데 덜 집중한다는 것을 의미합니다. 그때문에 객체는 아주 멍청한 상수 위에 자신만의 의미론을 덧붙여야 합니다. 결국 이 의미를 추가하기 위해서는 더 많은 코드를 작성해야할 것입니다.

### 대안

대안은 기능을 공유할 수 있도록 새로운 클래스를 만드는 것입니다. 그리고  데이터가 아니라 기능을 공유해야 한다는 것입니다.

```java
class EOLString { 
    private final String origin;
    
    EOLString(String src) { 
        this.origin = src; 
    }
	
    @Override
    String toString() { 
        return String.format("%s\r\n",origin); 
    }
}
```

EOLString 클래스로 기능 공유를 통해 사용하는 클래스들의 EOLString에 대한 결합은 계약을통해 추가된 것이며, 계약에 의한 결합은 언제라도 분리가 가능하기 때문에 유지보수성을 저하시키지 않습니다.

### 결론

결론은 퍼블릭 상수마다 계약의 의미를 캡슐화하는 새로운 클래스를 만들어야 한다는 것이고 수백 개의 단순한 상수 문자열 리터럴 대신 수백 개의 마이크로 클래스를 만들어야한다는 의미입니다. 

OOP에서 퍼블릭 상수를 정대로 사용해서는 안되며 Java의 열거형에 대해서도 정확하게 동일한 규칙이 적용됩니다.

## 2.6 불변 객체로 만드세요

불변 클래스(immutable class)로 구현하면 유지보수성을 크게 향상시킬 수 있습니다. 인스턴스를 생성한 후에 상태를 변경할 수없는 객체를 불변객체라고 부릅니다.

```java
// 불변 클래스
class Cash { 
    private final int dollars;
    
    Cash(int value) { 
        this.dollars = value; 
    }
	
    public Cash mul(int factor) { 
        return new Cash(this.dollars * factors); 
    }
}
```

```java
// 불변 객체
Cash five = new Cash(5); 
Cash fifty = five.mul(10); 
System.out.println(fifty);  // "$50"이 출력될 것이다.

// 만약 가변 객체 였다면 ?
Cash five = new Cash(5); 
five.mul(10);
System.out.println(five);  // "$50"이 출력될 것이다.
```

위의 예시의 핵심은 절대로 변경 가능한 객체를 만들지 말라는 것이다. 위 코드에서 객체 이름을 money로 변경하면 해결된다고 생각할 수도 있습니다. 가능은 하지만 매우 제한적(아주 간단한 경우에만 적용할 수 있으며)이며 일반적으로 이런 방법은 형편없는 전략입니다.

### 불변 객체의 장점

### 식별자 가변성(identity Mutability)

불변 객체를 사용하면 객체를 map에 추가한 후에는 상태 변경이 불가능하기 때문에 아래와 같은 '식별자 가변성'문제가 발생하지 않습니다.

```java
// 가변객체의 식별자 가변성 문제
Map<Cash, String> map = new HashMap<>(); 
Cash five = new Cash("$5"); 
Cash ten = new Cash("$10");
map.put(five, "five");
map.put(ten, "ten");
five.mul(2);

mapget(five); // "ten"과 "five" 중 하나가 반환될 것이다.
```

### 실패 원자성(Failure Atomicity)

불변 객체는 내부의 어떤 것도 수정할 수 없기 때문에 아래와 같은 결함이 발생하지 않습니다. 가변객체를 사용하더라도 '실패 원자성'이라는 목표를 달성할 수 있지만, 특별한 주의(예외 처리에 따른 롤백 등)를 기울여야 합니다.

```java
public class Cash { 
    private int dollars;
    private int cents;
    
    public mul(final int factor) { 
        this.dollars *= factor;
        if (/* 뭔가 잘못 됐다면 */) {
            throw new RuntimeException("oops..."); 
        }
        this.cents *= factor; 
    }
}
```

### 시간적 결합(Temporal Coupling)

불변 객체의 경우 인스턴스화와 초기화를 분리시킬 수 없기 때문에 시간적인 결합을 제거할 수 있습니다. 시간적인 결합이란 아래의 예시로 보면 'setter'들의 실행 순서가 그대로 유지되어야 하고 이들 모두 printlin()이전에 실행되어야 한다는 것과 같은 시간에 결합된 부분을 의미합니다.

```java
Cash price = new Cash(); 
// X를 계산하는 50줄의 코드
price.setDollars(29); 
// Y를 계산하는 30줄 이상의 코드
price.setCents(95); 
// 다른 일을 수행하는 25줄의 코드
System.out.println(price); // "$29.95"
```

### 부수효과 제거(Side effect-free)

객체가 가변적일때는 기본적으로 누구든 손쉽게 객체를 수정할 수 있으므로 부수효과가 나타나는데 불변객체는 언제 어디서든 변하지 않는 값으로 확신할 수 있고 부수효과가 일어나지 않습니다.

### NULL 참조 없애기

NULL을 참조하는 객체는 유지보수성이 저하될 수 박에 없습니다. 언제 객체가 유효한 상태이고 언제 객체가 아닌 다른 형태로 바뀌는 지를 이해하기 어렵기 때문입니다. 객체를 불변으로 만들면 객체 안에 NULL을 포함시키는 것이 애초에 불가능해집니다. 

### 스레드 안전성

객체가 여러 스레드에서 동시에(concurrently) 사용될 수 있으며 그 결과를 항상 예측가능하도록 유지할 수 있는 객체의 품질을 가지게 됩니다.

### 더 작고 단순한 객체

불변성의 장점인 단순성은 응집도가 높아지고, 유지보수하기는 더 쉬워집니다.

### 결론

불변성은 클래스를 더 깔끔하고 더 짧게 만듭니다. 이것이 바로 불변클래스를 이요할 때 얻을 수 있는 가장 중요한 장점입니다.

## 리뷰

종종 퍼블릭 상수를 사용해왔는데 2.5 챕터를 읽게 되면서 이 방식이 굉장히 결합도가 강하고 응집도를 낮추는 방법이었다는 것을 깨닫게 되었다. 
내 나름의 요약을 해보자면 퍼블릭 상수를 사용하면 상수 값을 수정해야하는 상황이 왔을 때 여러 사이드 이펙트를 고려해야해서 객체가 자신의 문제를 해결하는데 집중하지 못한다. 이 원인의 데이터를 의존하는 강한 의존성 때문이고 이를 위한 대안은 pirvate 상수 만을 사용하거나 새로운 클래스를 만들어 데이터가 아닌 기능을 의존하고 언제든지 의존성을 분리하기 쉽도록 만드는 것이다.

불변 객체는 항상 많이 사용하면서도 그에 따른 장점들을 단순하고 스레드 안전성 정도만 생각했는데 이번 기회에좀 더 많은 장점과 잘 사용하는 방법에 대해 배우게 되었다. JPA를 사용하고 있는 상황에서 엔티티를 불변으로 만들 수는 없겠지만 그 이외는 불변객체로 만들 수 있도록 고민해 볼 것이다.
