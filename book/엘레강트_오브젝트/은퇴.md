# 은퇴

## 4.1 절대 NULL을 반환하지 마세요

- 메서드의 인자에 null을 전달하는 것 만큼 null을 반환하는 방식 또한 매우 끔찍한 아이디어입니다. 만약 null을 반환하는 것을 허용한다면 객체 대한 **신뢰**가 무너졌다는 사실입니다.
- 반환값을 검사하는 방식은 애플리케이션에 대한 신뢰가 부족하다는 명백한 신호이며 신뢰의 부족은 유지보수성의 심각한 손실로 이어집니다.
- 하지만 우리는 무언가를 찾는 로직에서 null을 반환할 수 밖에 없다고 생각할 수 있습니다. 이 것에 대한 대안으로는 null 대신 예외를 던지거나, 컬렉션을 반환하거나, 널 객체(널이 아닌)를 반환하세요. 이것이 최선입니다.

    ```java
    // 널 객체 예시
    class NullUser implements User {
        private final String name;
    
        NullUser(String name) {
           this.name = name;
        }
    
        @Override
        public String name() {
           return this.name;
        }
    
        @Override
        public void rasie(Cash salary) {
           throw new IllegalStateException(
               "제 봉급을 인상할 수 없습니다. 저는 스텁(stub)입니다."
           );
        }
    }
    ```


## 4.2 체크 예외만 던지세요

- 언체크 예외를 사용하는 것은 실수이며, 모든 예외는 체크예외여야 합니다. 또한 다양한 예외 타입을 만드는 것도 좋지 않은 생각입니다.
- 언체크 예외의 경우 예외의 타입을 선언하지 않아도 무방한 반면에 체크 예외는 항상 예외의 타입을 공개해야 합니다.
- 항상 예외를 체이닝하세요
- 꼭 필요한 경우가 아니라면 예외를 잡지마세요
    - 반드시 예외를 잡아야하는 이유가 있거나 다른 선택의 여지가 없는 경우가 아니라면 예외를 잡아서는 안됩니다.
- 단 한번만 복구하세요
    - 예외 후 복구는 `흐름제어를 위한 예외사용`으로 알려진 안티패턴의 또 다른 이름일 뿐입니다.
- 관점-지향프로그래밍을 사용하세요
    - 어노테이션을 통한 복구

    ```java
    @RetryOnFailure(attempts = 3)
    public String content() throws IOException {
        return http();
    }
    ```


## 4.3 final이나 abstract이거나

- 상속에 반대하는 가장 강력한 주장은 상속이 객체들의 관계를 너무 복잡하게 만든다는 것입니다. 물론 이 주장도 일리는 있지만, 근본적인 원인은 상속 그 자체가 아닙니다. 문제를 일으키는 주범은 final이나 abstract가 아닌 가상메서드(일반적인 메서드) 입니다.
- 상속은 자식 클래스가 부모 클래스의 코드를 계승받는 하향식 프로세스입니다. 자식이 부모의 유산에 접근하는 일반적인 상속과 달리, 메서드 오버라이딩은 부모가 자식의 코드에 접근하는 것을 가능하게 합니다. 말하자면 이런 정반대의 사고 방식은 상식에서 어긋나는 것입니다.
- 따라서 상속이 적절한 경우는 클래스의 행동을 **확장**하지 않고 **정제**할 때입니다.

## 4.4 RAII를 사용하세요

- 리소스 획득의 초기화, 자바에서는 사라진 개념
- 가비지 컬렉션, try-with-resources