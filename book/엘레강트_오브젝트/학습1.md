# 학습 1/3

## 2.1 가능하면 적게 캡슐화하세요

4개 또는 그이하의 객체를 캡슐화할 것을 권장합니다. 더 많은 객체를 캡슐화해야 한다면, 클래스에 문제가 있는 것이기 때문에 리팩토링이 필요합니다. 예외는 없습니다.

OOP의 '객체'는 고수준의 행동을 낳기 위해 함께 동작하는 객체들의 집합체입니다. 
책은 페이지, 표지, ISBN의 집합체이고 책장은 책과 제목의 집합체입니다. 자동차는 바퀴,엔진, 앞 유리의 집합체이고 차고는 자동차와 주소의 집합체입니다. 나열한 예 들은 다른 객체를 캡슐화하지 않는 객체란 존재하지도 않으며 존재할수도 없는 사실을 잘 보여줍니다.

자바에서는 상태없는 객체를 만들 수 있지만
상태없는 객체는 존재해서는 안되고, 상태는 객체의 식별자여야 합니다.
객체의 식별자는 기본적으로 세계 안에서 객체가 위치하는 좌표입니다.

그리고 4개 이상의 좌표는 직관에 위배되며 4개 이상의 요소로 구성된 좌표를 이해하는 것은 너무나도 어렵습니다. 더 많은 객체가 필요하다면, 클래스를 더 작은 클래스들로 분해해야 합니다.

그리고 항상 equals()를 오버라이드하기 바랍니다.

## 2.2 최소한 뭔가는 캡슐화하세요

너무 많이 캡슐화하는 방식도 좋지 않지만, 아무것도 캡슐화하지 않는 방식 또한 바람직하지 않습니다.

프로퍼티가 없는 클래스는 객체지향 프로그래밍에서 악명이 높은 정적 메서드(static method)와 유사합니다. 이런 클래스는 아무런 상태와 식별자도 가지지 않고 오직 행동만을 포함하는데 인스턴스 생성과 실행을 엄격하게 분리하는 순수한 OOP에서는 기술적으로 프로퍼티가 없는 클래스를 만들 수 없습니다. (없어야 합니다)

섹션 2.1에서 설명했던 것처럼 캡슐화된 상태는 세계 안에서 객체의 위치를 지정하는 고유한 식별자입니다. 객체가 어떤 것도 캡슐화 하지 않는다면 객체의 좌표는 무엇일까요? 바로 객체 자신이 세계 전체가 되어야 합니다.

```java
class Universe {
}
```

## 2.3 항상 인터페이스를 사용하세요

객체는 살아있는 유기체입니다. 객체는 다른 유기체들과 의사소통하며 그들의 작업을 지원하고, 다른 유기체들 역시 이 객체에 도움을 제공합니다. 여기에서 말하고 싶은 점은 객체들이 서로를 필요로 하기 때문에 **결합된다는(coupled)** 것입니다.

애플리케이션이 성장하며 객체들의 수가 수십개를 넘어가면서부터 객체 사이의 **강한 결합도(tight coupling)가** 심각한 문제로 떠올랐고 이 문제는 유지보수성에 영향을 미칩니다.
유지보수 가능하도록 만들기 위해서는 최선을 다해서 객체를 분리해야(decouple)합니다.
그리고 가장 훌륭한 도구가 바로 **인터페이스(inteface)** 입니다.

```java
interface Cash {
	Cash multiply(float factor);
}
```

Cash는 인터페이스이며 우리의 객체가 다른 객체와 의사소통하기 위해 따라야 하는 **계약(contract)** 입니다.

```java
class DefaultCash implements Cash {
	private int dollars;

	DefaultCash(int dlr) {
		this.dollars = dlr;
	}

	@Override
	Cash multiply(float factor) {
		return new DefaultCash(this.dollars * factor);
	}
}
```

금액이 필요하다면 실제 구현 대신 계에 의존하면 됩니다.

```java
class Employee {
	private Cash salary;
}
```

Employee 클래스는 Cash 인터페이스의 구현 방법에 아무런 관심이 없으며 Cash의 구현체는 언제든지 교체될 수 있습니다. 

클래스 안의 모든 퍼블릭 메서드가 인터페이스를 구현하도록 만들어야하며 이를 통해 우리는 **느슨한 결합도(loose coupling)**을 만들어야합니다. ****

## 2.4 메서드 이름을 신중하게 선택하세요

올바르게 지은 메서드의 이름은 사용자들이 객체를 설계한 목적, 객체가 수행해야 하는 임무, 객체의 존재 목적과 살아가는 의미를 더 잘 이해할 수 있도록 해줍니다. 부적절하게 지은 메서드 이름은 객체의 전체적인 개념을 망가트리고 사용자들이 객체를 데이터 집합이나 프로시저들의 모음으로 다루도록 종용합니다.
객체는 자신의 의무를 수행하는 방법을 알고 있고 존중 받기를 원하는 **살아있는 유기체**입니다.

제안하는 메서드를 짓는 방법은 빌더(builder)의 이름은 **명사**로, 조정자(mainipulator)의 이름은 **동사**로 짓는 것입니다.

### 2.4.1 빌더는 명사다

**빌더(builder)** 란 뭔가를 만들고 새로운 객채를 반환하는 메서드를 가리킵니다. 빌더는 항상 뭔가를 반환하고 반환 타입은 절대 void가 될 수 없으며, 이름은 항상 명사여야합니다.

```java
float speed();
Employee employee(int id);
String parsedCell(int x, int y);  // 풍부한 의미를 가지는 메서드의 이름

// 메서드 이름이 잘못 지어진 제과점 클래스
class Bakery {
	Food cookBrownie();  // 올바른 이름: brownie() 
	Drink brewCupOfCoffee(String flavor); // 올바른 이름: cupOfCoffe() 
}
```

제과점 클래스를 보면 우리의 관심사는 브라우니를 요리하거나 하는 커피를 끓이는 정확한 방법은 제 관심사가 아닙니다. 우리는 단지 객체에게 브라우니와 커피를 요구하고 객체들은 그 요구를 만족시켜 주어야 합니다.

### 2.4.2 조정자는 동사다

**조정자(manipuloatr)** 란 객체로 추상화한 실세계 엔티티를 수정하는 메서드로 반환타입은 항상 void이며 이름은항상 동사입니다.

```java
void save(String content)
void remove(Employee emp)
void quicklyPrint(int id); // 풍부한 의미를 가지는 메서드 이름
```

그리고 개념적으로 빌더와 조정자 사이에는 어떠한 메서드도 존재해서는 안됩니다. 즉, 뭔가를 조작한 후 반환하거나, 뭔가를 만드는 동시에 조작하는 메서드가 있어서는 안된다는 것입니다.

```java
// 저장된 전체 바이트를 반환
int save(String content); 
// map이 변경된 후 TRUE를 반환
boolean put(String key, Float value);
```

save() 메서드는 조정자 이기 때문에 void를 반환하도록 바꾸거나 bytesSaved()와 같은 이름으로 바꿔야 합니다. put()메서드 역시 마찬가지이며 문제를 해결하기 위해서는 PutOperation의 인스턴스를 반환하도록 클래스의 설계를 수정하고 PutOperation 클래스는 조정자인 save() 메서드와 성공/실패 여부를 반환하는 빌더인 success() 메서드를 구현함으로 대체할 수 있습니다.

### 2.4.3 빌더와 조정자 혼합하기

위의 PutOperation 클래스처럼 중간 연산을 하는 인스턴스로 리팩토링이 가능합니다.

```java
class Discoument {
	int write(InputStream content);
}

// 리팩토링
class Discount {
	OutputPipe output();
}
class OutputPipe  {
	void write(InputStream content);
	int bytes();
	long time();
}
```

output()은 빌더로 wirte()는 조정자로 리팩토링되었습니다.

### 2.4.4 Boolean 값을 결과로 반환하는 경우

Boolean 값을 반환하는 메서드는 규칙에 있어 예외적인 경우이며 가독성 측면에서 이름은 **형용사**로 지어야합니다.

```java
boolean empty(); // is empty
boolean readable(); // is readable
```

접두사 'is'는 중복이기 때문에 메서드 이름에는 포함시키지 않지만, 메서드를 읽을 때는 일시적으로 앞에 붙여 자연스럽게 들리도록 해야합니다. 즉, 메서드를 읽을 때는 접두사 is를 추가하고 실제 코드에서는 빼야한다는 뜻입니다.

### 리뷰

2.4를 통해 올바른 메서드의 이름이 객체의 존재 목적을 나타내는 아주 좋은 수단이 된다는 것을 많이 느꼈다.  
항상 메서드 이름과 반환 값에 대해 고민하던 나에게 정말 단비 같은 챕터 이지 않았나 싶다.  
하지만 여기서 나온 규칙도 실무에 적용하기에는 몇가지 고민이 앞선다. 

1. getter와 같은 전통적인 방식
2. 회사의 내부 컨벤션

이 두가지는 내가 이 책을 통해 알게된 규칙 보다는 더 우선시 되어야 할 것이다.  

그럼에도 중요한 사실은 이 챕터를 통해 앞으로 나는 조금 더 우아한 메서드 이름을 짓게 될 것이라는 사실이다.
