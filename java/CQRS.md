# CQRS (Command Query Responsibility Segregation)

## 단일 모델의 단점
주문 내역 조회 기능을 구현하려면 여러 애그리거트에서 데이터를 가져와야한다.  
Order에서 주문 정보, Product에서 상품이름, Member에서 회원 이름과 아이디...  
조회할 때 애그리거트간에 참조가 DDD의 개념에 맞게 간접 참조 되었다면 즉시로딩으로 최적화하기 힘들다.  
만약 직접 참조하여 관계를 맺더라도 지연로딩과 즉시로딩을 통한 최적화는 한계가 있으며 JPA의 네이티브 쿼리를 사용하게 할 수도 있다.  

이런 고민이 발생하는 이유는 변경과 조회할때 모두 같은 단일 도메인 모델을 사용하기 때문이다.  
단일 모델은 변경에는 적합한 모델이지만 조회에는 그렇지 못하며 조회를 위한 모델을 만듬으로써 분리하게 된다면 이런 구현 복잡도를 낮출 수 있다. (=CQRS)  
**ex) Order 모델 vs OrderSummary 모델 (데이터베이스까지 분리 하여 사용할 수도 있다.)**

## CQRS 란?
- 상태를 변경하는 명령(Command)를 위한 모델과 상태를 제공하는 조회(Query)를 위한 모델을 분리하는 패턴.
- 복잡한 도메인에 적합하며 도메인이 복잡할수록 명령 기능과 조회 기능이 다루는 데이터 범위에 차이가 발생하는데, 
  이때 CQRS를 적용함으로써 조회의 성능을 높일 수 있다. 
   
## CQRS 장점
- 명령 모델을 구현할때 도메인 자체에 집중 할 수 있다.
    - 복잡한 도메인은 주로 상태 변경 로직이 복잡하다.
    - 조회 성능을 위한 코드가 명령 모델에서 사라져 복잡도를 낮출 수 있다.
  
- 조회 성능을 향상시키는데 유리함
    - 조회에 특화된 쿼리를 마음대로 사용 할 수 있다.
    - 캐시 뿐만 아니라, 조회 전용 저장소(NoSql 등)를 사용하여 조회 처리량을 대폭 늘릴 수 있다.  
    - 조회 전용 모델을 사용하기 때문에 조회 성능을 높이기 위한 코드가 명령 모델에 영향을 주지 않는다.
    
## CQRS 단점
- 구현해야 할 코드가 많고 많은 구현 기술이 필요하다.
    - 단순하거나 트래픽이 많지 않다면 오히려 유지보수만 힘들게 한다.
    - 명령모델과 조회 모델의 저장소가 다를 경우 데이터 동기화를 위한 메시징 시스템도 도입해야 할 수도 있다.

## CQRS 활용
- CQRS 적용 전
    - MSA 아키텍쳐에서 조회가 몰리는 서버가 있다면 그 서비스가 에러가나면 에러가 전파된다. (해당 조회 API를 호출하는 곳은 모두 에러)
    - 조회가 매우 많아 트래픽이 커지면 이 큰 트래픽을 여러 서버에 전파하게 된다.  
    (성능보다 정확성을 요하는 서버에게는 이 트래픽은 감당할 수 없는 것이다.)  
    
- CQRS 적용
    - 각 서버가 각자 역할에 맡는 쿼리모델을 가지고 있다.
    - AWS SNS & SQS를 통한 이벤트로 동기화 방법과 같은 데이터 동기화 방안이 필요하다. (Zero-payload 방식)  
    **Zero-payload** : 최소한의 데이터만으로 이벤트를 발행하고 각 서버가 원본 데이터가 있는 서버에 자기 입맛에 맞는 데이터를 가져갈 수 있도록 하는 방식.
    - 동기화 후 여러가지 방법을 통해 자신의 데이터를 저장해둔다. (Redis, Cache, DynamoDB ...) 
    - 적용 후 트래픽을 다른 서버에 전파하지 않으며 한 서버가 장애가 발생되더라도 다른 서버에 영향이 없다. 
