# 컬렉션 패치조인 시 페이징 (부제: HHH000104: firstResult/maxResults specified with collection fetch; applying in memory)

## 결론부터 말하자면 컬렉션을 패치조인하면 페이징이 불가능하다.
- 컬렉션을 패치조인하면 데이터가 일대다 관계에서 일(One)을 기준이 아닌 다(Many)를 기준으로 조인되어 데이터가 row가 증가한다. (패치조인의 조인전략은 내부조인이기 때문)
- 이렇게 증가된 데이터는 페이징의 주체를 바뀌게 만든다. 나는 일(One)을 기준으로 페이징을 원하였는데 다(Many)를 기준으로 페이징이 되는 상황이 된다.
- 게다가 의도치 않게 컬렉션과 패치조인 후 페이징을 시도한다면 하이버네이트는 아래와 같은 경고를 남기고 조인한 모든 데이터를 DB에서 읽어와 메모리에서 페이징을 시도한다.  
`HHH000104: firstResult/maxResults specified with collection fetch; applying in memory` 
- 이 행위는 장애까지 이어질 수 있으므로 무조건적으로 피해야한다.
    
## 어떻게 해결할 수 있을까 ?
- 컬렉션을 패치조인하지 않고 지연로딩으로 사용한다. 단, 지연로딩 성능 최적화를 위한 설정을 적용한다.
- 설정을 적용하면 컬렉션 지연로딩 조회 시 **in 쿼리**로 적용해 놓은 사이즈만큼 한번에 조회하여 가져온다.
    
## 적용 방법
- `@BatchSize`
    - 개별 설정을 위한 어노테이션으로 컬렉션에 지정해주어 사용한다. 
    ```java
    public class Order {
        @BatchSize(size = 100)
        @OneToMany
        private List<OrderItem> orderItems = new ArrayList<>();
    }
    ```
- `hibernate.default_batch_fetch_size`
    - 글로벌 설정으로 프로퍼티에 등록하여 사용한다.
    ```java
    spring.jpa.properties.hibernate.default_batch_fetch_size = 100
    ```
    
## 적절한 BatchSize는 ?
- 권장은 100~1000 사이를 권장한다.
- 1000으로 설정하는 것이 가장 좋지만 DB나 어플리케이션에 순간 부하를 주기 때문에 잘 고민해보고 결정해야한다.
- 1000 이상으로 원할 경우 데이터베이스에 따라 SQL IN 절에 파라미터가 1000으로 제한되어 있는 경우가 있기 때문에 조심하자.

## 참고
[스프링 부트와 JPA 활용2 - API 개발과 성능 최적화 - 김영한님](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81%EB%B6%80%ED%8A%B8-JPA-API%EA%B0%9C%EB%B0%9C-%EC%84%B1%EB%8A%A5%EC%B5%9C%EC%A0%81%ED%99%94/dashboard)
