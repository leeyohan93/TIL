# 우아한테크캠프pro 리뷰 학습 정리
    
## 1. 자동차 경주 - 단위 테스트

### 1-1. getter를 지양하는 이유는 객체간의 역할과 책임을 잘 분배해야 한다
### 1-2. wrapper객체를 사용할 때 생존 범위를 잘 고려해야한다.
### 1-3. 표준 예외를 사용하라
- Unchecked exception(RuntimeException의 하위 구현체들)사용을 선호
- ControllerAdvice에서 특정 에러에 대한 다른 처리를 해주어야 하는 경우에만 CustomException을 사용
- 예외와 에러의 차이
    - 예외란 입력 값에 대한 처리가 불가능하거나, 프로그램 실행 중에 참조된 값이 잘못된 경우 등 정상적인 프로그램의 흐름을 어긋나는 것을 말한다. 
    그리고 자바에서 예외는 개발자가 직접 처리할 수 있기 때문에 예외 상황을 미리 예측하여 핸들링할 수 있다.
    - 예외에서 RuntimeException을 상속하지 않는 클래스는 Checked Exception, 반대로 상속한 클래스는 Unchecked Exception으로 분류할 수 있다.
    - 에러는 시스템에 무엇인가 비정상적인 상황이 발생한 경우에 사용된다. 
    주로 JVM에서 발생시키는 것이며 예외와 반대로 이를 애플리케이션 코드에서 잡으려고 하면 안 된다. (사실 잡아도 방법이 없다.) 
    에러의 예로는 OutOfMemoryError, ThreadDeath, StackOverflowError 등이 있다.

## 2. 로또 - TDD

### 2-1. 상속보다는 Composition

상속은 강력하지만 캡슐화를 해친다는 문제가 있고 상속은 상위 클래스와 하위 클래스가 순수한 is-a 관게일때만 사용해야한다.  

상속이 적절한 경우란 언제일까? 클래스의 행동을 확장하는 것이 아니라 정제할 때다. 확장이란 행동을 덧붙여 기존의 행동을 부분적으로 보완하는 것을 의미하고 정제란 불안전한 행동을 완전하게 만드는 것을 의미한다.

### 2-2. 접근 제어자
- private: 같은 클래스만 접근 허용
- default: 같은 패키지 접근 허용
- protected: 같은 패키지 접근 허용, 다른 패키지에 속하는 자식 클래스도 접근 허용
- public: 누구나 접근 허용

## 3. JPA

### 3-1. Auditing
애플리케이션의 엔티티의 생성 시간과 마지막 수정 시간을 관리할 필요가 있다면 수동으로 매번 추가하는 대신 Auditing 기능을 이용하여 자동으로 추가해 줄 수 있다.

### 3-2. Embedded vs AttributeConverter

- Embedded - 엔티티에서 새로운 값 타입을 직접 정의해서 사용할 때 사용.  
값 타입은 복잡한 객체 세상을 조금이라도 단순화 하려고 만든 개념.
- AttributeConverter - 엔티티의 데이터를 변환해서 데이터 베이스에 저장 (ex. Money)

### 3-3. 불변객체
한번 만들면 절대 변경할 수 없는 객체를 불변 객체라 한다.

- 모든 클래스를 상태를 변경할 수 없는 불변클래스로 만들면 유지 보수성이 크게 향상된다.
- 단순성 - 객체가 더 단순해질 수록 응집도가 높아지고 유지보수가 쉬워진다
- 식별자 변경 문제가 발생하지 않는다.  (HashMap)
- 객체가 완전하고 견고한 상태이거나 아예 실패하는 실패 원자성을 가진다.
    - 메서드 실행 중간에 예외가 발생했다면 가변 객체는 특별한 주의를 기울여서 처리를 해야한다.
    - 그러나 불변 객체는 별도의 처리가 없어도 원자성을 가지고있기 때문에 문제가 없다.
- 시간적 결합을 없앨 수 있다.
    - 시간이 지나도 값을 변경할 수 없다
    - 누군가가 값을 임의로 변경하는 사태를 막을 수 있다.
- 스레드 안정성
    - 객체가 멀티 스레드에 동시에 사용될 수 있고 예측 가능한 결과를 보장한다.
- 객체의 공유 참조에도 문제가 없다.
    - 가변성은 문제가 있음

## 4. 인수테스트 주도 개발

### 4-1. 추상화 수준에 맞는 예외를 던지라
아래 계층의 예외를 예방하거나 스스로 처리할 수 없고, 그 예외를 상위 계층에 그대로 노출하기 곤란하다면 예외 번역을 사용하라. 이때 예외 연쇄를 이용하면 상위 계층에는 맥락에 어울리는 고수준 예외를 던지면서 근본 원인도 함께 알려주어 오류를 분석하기에 좋다.

### 4-2. 컬렉션 로딩시 batch size
- 데이터가 일대다 관계에서 일(One)을 기준이 아닌 다(Many)를 기준으로 조인되어 데이터가 증가한다.
- 컬렉션을 페치조인하지 않고 **지연로딩**으로 사용한다. 단, 지연로딩 성능 최적화를 위한 설정을 적용한다.
- 최적화 설정을 적용하면 컬렉션 지연 로딩 조회 시 in 쿼리로 적용해 놓은 사이즈만큼 한 번에 조회하여 가져온다

### 4-3. 이벤트 소싱
이벤트 소싱은 도메인 모델에서 발생하는 모든 이벤트를 기록하는 데이터 저장 기법이다.
- 장점
    - 버그 추적 용이 (이벤트들을 추적하기 좋다)
    - MSA와 좋은 시너지
    - 객체 지향과 좋은 궁합
    - **임피던스 불일치(객체-관계 불일치)가 존재하지 않는다.**
        - 도메인에 새로운 상태가 추가되어도 DB와 도메인 모델 사이의 임피던스 불일치가 발생하지 않는다.
- 단점
    - 어렵다, 단순모델에 적합하지 않다.
    - 복합 조회 문제
        - 이벤트들을 다 가져와서 재생 한 후에 조회해야 하기 때문에. (필수로 CQRSD와 사용함)
- 조합
    - MSA - 비동기 작업 흐름에 알맞게 동작한다.
    - CQRS - 이벤트 저장소가 비즈니스의 다양한 데이터 조회 요구를 수용하기 어렵다는 점을 해결한다.

## 5. 인수테스트 기반 TDD
- 다른 애그리거트를 참조하는 것은 문제가 아니다.  
중요한 것은 도메인 룰에 대한 책임을 적절한 애그리거트가 가지는 것이다.

## 6. 레거시 코드 리팩터링

## 7. 자바 8

### 7-1. 람다
- 익명 클래스의 필요성을 제거하고 매우 간단하게 함수형 프로그래밍을 사용 가능

### 7-2. 함수형 인터페이스
- 하나의 메소드만 선언되어 있는 interface. 인터페이스 선언시 @FunctionalInterface 어노테이션을 사용하면 해당 인터페이스는 내용이 없는 하나의 메소드만 선언 할 수 있다. 두개 선언 시 컴파일 오류!

### 7-3. 인터페이스 기본 메소드
- 만든 이유는 '하위 호환성' 때문이다. 많은 사람이 사용하고 있는 인터페이스에 새로운 메소드를 추가해야 할 때 기존 방식대로 추가하면 이미 사용하고 있는 사람들은 전부 오류가 발생하고 수정해야하는 일이 발생한다. 이럴 때 사용하는 것이 default 메소드다.+ Lambda 표현식을 사용하기 위해서 만들어졌다.(lambda 표현식을 사용하려면 메소드가 1개여야 하는데 그 이외의 메소드는 default method로 구성되게 만들면 되기 때문이다)

### 7-4. 스트림
- 자바의 자료구조들을 선언적으로 다루는 역할을 하며 람다를 활용할 수 있는 기술.
- Stream은 Collection류의 객체에 사용할 수 있는 함수형 인터페이스를 통한 간단한 내부 데이터 순회 방법이다.
- 병렬 연산 처리시 공유된 쓰레드 풀을 사용하기 때문에 심각한 성능 장애를 일으킬 수 있따.
- 스트림과 컬렉션의 차이는 데이터를 계산 시점의 차이! / 외부반복, 내부반복

### 7-5. 옵셔널
- null 처리를 보다 간편하게 하기 위해서 만들어졌다.

### 7-6. 함수형 프로그래밍이란
함수를 이용해서 **사이드 이펙트 없도록** 선언형 프로그래밍을 이용하는 것이다.  
상태를 가지지 않는 것이 OOP와의 차이점이다.
