# 우아한 객체지향

해당 내용은 조영호님의 [우아한 객체지향](https://www.youtube.com/watch?v=dJ5C4qRqAgA) 이라는 
테크 세미나 영상을 기반으로 정리한 내용입니다.

## 다루는 두가지 문제

### 0. 문제를 찾기 위해 내 코드의 의존성을 찾아라
- 패키지 간의 의존성 그림을 그려보아라.
- 의존성의 사이클이 돈다면 패키지를 잘못 설계했을 수도 있고 의존성을 분리해내야 할 필요가 있는 것이다.

### 1. 객체 참조로 인한 결합도 상승
- 객체 참조로 모두 연결되어 있다면 대체 어디까지 조회해야 하는가? (LazyLoading 이슈)
- 객체 그룹의 조회 경계가 모호
- 수정 시 도메인 규칙을 함께 적용할 경계는 어디까지? == 트랜잭션의 경계가 모호해지고 트랜잭션이 길어지는 것을 유발한다.
- 도메인 별로 변경의 주기가 다른데 함께 트랜잭션으로 묶이는 것은 매우 위험하며 트랜잭션 락이 발생하기 쉽다.

### 2. 패키지 의존성 사이클
- 한 패키지의 변경 사항이 생겼을 때 다른 패키지도 변경해야한다.

## 설계를 개선하는 방법

## 1. 객체 참조를 끊고 간접 참조로 약한 결합도로 만들기.
객체 참조를 끊고 간접 참조한 필드로 Repository를 통해 조회함으로 써 약한 결합도를 만들면 된다.
- 어떤 객체들을 묶고 어떤 객체들을 분리할 것인가?
  - 함께 생성되고 함게 삭제되는 객체들을 함께 묶어라.
  - 도메인 제약사항을 공유하는 객체들을 함께 묶어라.
  - 가능하면 분리하라.
  - 객체들을 묶고 분리하는 것은 시스템 마다 비즈니스에 따라 다를 수 있다.
- 이렇게 분리하게 되면 조회의 단위, 트랜잭션 경계가 명확해지고 그룹 단위의 영속성 저장소도 변경이 가능하다.

### 1-1. 절차지향 로직
- 절차지향적인 로직들을 모아 하나의 Service나 Validator를 만드는 방식.
- 때로는 절차지향이 객체지향보다 좋다.
- 이렇게 분리해내게 되면 `Order`와 같은 경우는 좀 더 비즈니스 로직에 집중할 수 있다.
- 트레이드 오프의 영역이므로 잘 판단하는 것이 중요하다.
- 이렇게 만들었을 때 의존성의 사이클이 도는지 확인하여 의존성의 사이클을 끊어주어야 한다. 

## 2. 패키지 의존성 사이클 끊기

### 2-1. 중간객체 사용

| shop | 중간객체 | order |
| ---- | ----- | ------ |
| OrderOptionGroupSpecification | OptionGroup | OrderOptionGroup |
| OptionSpecification | Option | OrderOption |

- 중간 객체는 클래스로 구현한 추상화이며 어떻게 보면 DIP의 변형과도 같다.
- 중간 객체에서는 로직에 꼭 필요한 상태 값을 가지거나 필요한 로직만을 가질 수 있다는 장점이 있다.

### 2-2. 인터페이스나 추상클래스를 통해 의존성을 역전
- 인터페이스는 order 쪽에 구현하고 구현체는 delivery 쪽에 구현하는 것과 같은 방식

### 2-3. 도메인 이벤트 퍼블리싱과 새로운 패키지 추가
- 이벤트를 발행하고 각기 다른 도메인에서 처리하는 것.
- order에서 이벤트를 발행하고 shop과 delivery 각각의 EventHanlder에서 받아서 처리하는 것과 같은 방식
- 이벤트 반영 후에도 의존성 사이클이 돈다면 패키지를 분리해야하는 상황일 수도 있다.
