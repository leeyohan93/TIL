# JPA 1차 캐시 사용시 주의점

## 1차 캐시란?
영속성 컨텍스트는 내부에 캐시를 가지고 있는데 이것을 1차 캐시라 한다.
영속 상태의 엔티티는 엔티티의 식별자를 키로 모두 이곳에 저장된다.

## 1차캐시의 장점
영속 엔티티의 동일성을 보장해주는데 이 부분은 `반복 가능한 읽기(REPEATABLE READ)` 의 트랜잭션 격리 수준을 
데이터베이스가 아닌 애플리케이션 차원에서 제공한다는 뜻이다.

## 1차캐시의 동작 방식

### 1. 엔티티 매니저를 통해 조회
엔티티 매니저를 통해 조회할 경우 두가지로 나뉜다.

1. 1차 캐시에서 식별자(pk)에 해당하는 엔티티 존재 -> 메모리 안에 있는 1차 캐시에서 엔티티 반환

2. 1차 캐시에서 식별자(pk)에 해당하는 엔티티 존재 하지 않음 -> 데이터베이스를 조회해서 엔티티를 생성하고 1차 캐시에 저장한 후 엔티티를 반환


### 2. JPQL을 통해 조회
JPQL을 통해 조회할 경우에는 1차 캐시의 엔티티 존재 유무와 상관없이 데이터베이스를 우선적으로 조회한다.  
그리고 이 조회한 값을 영속성 컨텍스트의 1차 캐시에 저장하는데, 만약 이미 1차 캐시에 같은 엔티티가 존재한다면 데이터를 저장하지 않는다.

## 1차캐시 사용 시 주의점
1차 캐시와 같은 경우는 영속성 컨텍스트를 사용하면 다른 설정없이 자동으로 사용하게 되는데 조심해야할 상황들이 존재한다.
```java
Member memberA = new Member();
memberA.setName("A");
memberRepository.save(member);

Member memberA = memberRepository.findByName("A");
memberA.setName("B");

// 어떤 코드를 실행시켜야 할까?
Member result1 = memberRepository.findByName("A");  // 1번
Member result2 = memberRepository.findByName("B");  // 2번
```
위와 같이 코드가 있을 때 어떤 코드를 실행시켜야 name을 B로 변경한 Member 객체를 얻을 수 있을까?  
답은 2번이다. 그 이유는 findByName()과 같은 쿼리 메서드는 JPQL로 동작하게 되는데 JPQL이 동작하기 전에 
영속성 컨텍스트를 플러쉬하면서 엔티티의 변경사항을 데이터베이스에 업데이트 하게 된다. (더티체킹)  
따라서 2번을 실행시켜야 정상적인 결과를 얻을 수 있다. 


그렇다면 만약 해당 로직이 읽기 전용 트랜잭션으로 설정되어 있다면 어떻게 될까?  
그 때는 1번 로직을 실행시켰을때 정상적인 결과를 있을 것이라 생각할 수 있지만 반은 맞고 반은 틀리다.  
result1에 예상하였던 객체가 조회가 되었지만 그 안에 name을 확인하면 "B"가 출력될 것이기 때문이다.
이 현상은 앞서 말했던 2-2에서 1차 캐시에 같은 엔티티가 존재하기에 데이터를 저장하지 않고 버렸기 때문이다.


자주 만나게 될 상황일지는 모르지만 확실히 알고 있어야하는 부분이라고 생각한다. 


## 참고
- 자바 표준 ORM JPA 프로그래밍 (김영한)
