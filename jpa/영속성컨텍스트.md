# 영속성 컨텍스트

### 엔티티를 영구 저장하는 환경
- 엔티티 매니저를 통해서 접근할 수 있고, 하나의 트랜잭션 마다 영속성 컨텍스트가 생성된다.

### 엔티티의 생명주기
- 비영속: 영속성 컨텍스트와 전혀 관계가 없는 상태
- 영속: 영속성 컨텍스트에 저장된 상태
- 준영속: 영속성 컨텍스트에 저장되었다가 분리된 상태
- 삭제: 삭제된 상태

### 영속성 컨텍스트의 특징
- 영속성 컨텍스트는 엔티티를 식별자 값(@id로 테이블의 기본 키와 매핑한 값)으로 구분한다. 따라서 영속 상태는 식별자 값이 반드시 있어야 한다. 식별자 값이 없으 면 예외가 발생한다.

### 영속성 컨텍스트의 장점
- 1차캐시
    - 영속성 컨텍스트는 내부에 캐시를 가지고 있는 것. 영속 상태의 엔티티는 모두 이곳에 저장된다.
    - 반복 가능한 읽기(REPEATABLE READ) 등급의 트랜잭션 격리 수준을 데이터베이스가 아닌 애플리케이션 차원에서 제공한다는 장점
- 트랜잭션을 지원하는 쓰기 지연
    - 엔티티 매니저는 트랜잭션을 커밋하기 직전까지 데이터베이스에 엔티티를 저장 하지 않고 내부 쿼리 저장소에 INSERT SQL을 차곡차곡 모아둔다. 그리고 트랜잭션을 커밋할 때 모아둔 쿼리를 데이터베이스에 보내는데 이것을 트랜잭션을 지원 하는 지연쓰기라 한다. 데이터베이스에 한 번에 전달하므로 성능을 최적화 할 수 있다.
- 변경 감지
    - JPA는 엔티티를 영속성 컨텍스트에 보관할 때，최초 상태를 복사해서 저장해두는데 이것을 스냅샷이라 한다. 그리고 플러시 시점에 스냄샷과 엔티티를 비교해서 변경된 엔티티를 찾는다.
    - 기본적으로 모든 필드를 업데이트하며 대략 30개이상에서는 동적 쿼리 수정이 빠르다고한다. 하지만 30개 이상이라면 설계가 틀린 것이다.
- 동일성 보장: 1차 캐시를 통한 동일성 보장
- 지연로딩

### 플러시
- 플러시는 영속성 컨텍스트의 변경 내용을 데이터베이스에 동기화하는 작업
- 플러시를 실행하면 변경감지가 동작하고 쓰기 지연 SQL 저장소의 쿼리를 데이터베이스에 전송한다.
- 플러시하는 방법: em.flush(), 트랜잭션 커밋, JPQL 쿼리 실행
    
### 저장 흐름
- save() 호출 → 1차캐시 저장 → 쓰기 지연 SQL 저장소 → 트랜잭션 커밋 → flush() →   쓰기 지연 SQL 저장소 DB 반영 → 트랜잭션 커밋
    
### 조회 흐름
1. find() 호출 → 1차캐시 존재 → 반환
2. find() 호출 → 1차캐시 없음 → DB 조회 → 1차 캐시 저장 → 반환
    
### 변경감지 흐름
- 엔티티 변경 → 트랜잭션 커밋 → flush 호출 → 스냅샷과 변경된 엔티티 찾기 → 변경된 엔티티의 수정쿼리를 쓰기 지연 저장소로 보냄 → 쓰기 지연 저장소에서 DB 반영 → 트랜잭션 커밋
